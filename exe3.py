# -*- coding: utf-8 -*-
"""Exe3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e8SyRRbDMur_WKA4CKnKTkIdiSp_Zzdn

# <center><font color='Crimson' style="font-size:40px"><b>Exercises 3</b></font></center>

## <font color='Tomato'><b>1. Basics of portfolio theory and portfolio optimization</b></font>

### A

a) Import data about <u>15 chosen stocks</u> from <u>third sheet</u> of file "optimization.xlsx" (Google Colab users need to upload the file first).
"""

from google.colab import files
uploaded0=files.upload()

from google.colab import files
uploaded1=files.upload()

import pandas as pd
import numpy as np
import numpy.linalg as LA
import scipy.optimize as sco
import scipy.stats as st
import datetime as dt
import kvantitativne_formule as qt
import plotly.graph_objects as go

"""* Import <font color='MediumSeaGreen'><b>Panda</b></font>s:"""

ret15 = pd.read_excel("optimization.xlsx",sheet_name=2,index_col=0)
ret15.head()

"""b) Assume that you **currently posses** an portfolio which **weights** are presented in **list below**. What is **expected return and risk** of your portfolio?"""

w=[0.35,0.04,0.2,0.1,-0.1,0.01,0.07,0.25,-0.1,0.01,0.02,0.05,-0.2,0.25,0.05]

"""* **Two ways** to deal with this:
    1. Treat portfolio as **an asset**:
        * Compute **portfolio returns**, than compute its **financial descriptive statistics**
    2. Treat portfolio as **collection of assets**:
        * Compute portfolio's financial descriptive statistics directly from **constituents stocks' returns**.

#### <font color='Indigo'><b>1. From portfolio returns (Portfolio as an asset)</b></font><br>

* Compute portfolio returns
"""

rp = ret15@w
rp

"""* Next we can **compute financial descriptive statistics** for this new data (portfolio returns)
    * First, you need to import our small module <font color='DarkTurquoise'><b>kvantitativne formule</b></font>
"""

qt.expRet(ret15),qt.annualize_vol(ret15)

er=qt.expRet(rp)
print(er)
vol=qt.annualize_vol(rp)
print(vol)

"""#### <font color='Indigo'><b>2. From stocks' returns (Portfolio as collection of assets)</b></font><br>

* You have derived these properties in class (they are based on linear algebra)
* We will use this approach in our **further analysis** since it is **more convenient**

* We use function <font color='Blue'><b>per</b></font> to compute expected returns on portfolio:

$$E(r_p)=W \cdot E$$
"""

per = qt.per(W=w,ret=ret15)
per

"""* We use function <font color='Blue'><b>pV</b></font> to compute risk of portfolio:
    * Set parameter ***vol*** to True to compute volatility

$$V(r_p)=W'\cdot \Sigma \cdot W$$
"""

pV = qt.pV(W=w,ret=ret15,vol=True)
pV

"""### C

c) Assume that you think that **risk** of almost 23% annually is **too high**. Find optimal portfolio which **minimizes total risk** of investment.

* Find weights which **minimize portfolio volatility** subjected to **budget constraint**

$$(\min)\hspace{2mm}W\cdot\Sigma\cdot W$$

$$\text{s. t.}\hspace{2mm}W\cdot l=1$$

* Where $l$ is vector which consists only of ones:
 $$W\cdot l=\sum_{i=1}^{n}w_i=1$$

* This is notation for summation in linear algebra

#### <font color='Indigo'><b>Computation</b></font><br>
* We use function <font color='Blue'><b>mvp</b></font> to find MVP:
"""

mvp = qt.mvp(ret=ret15)
mvp

"""* Output is a **dictionary** which consists of:
    1. Optimal weights
    2. Expected return on optimal portfolio
    3. Volatility
"""

mvp['w']

"""#### <font color='Indigo'><b>Manual optimization 1</b></font><br>

* We need to import <font color='MediumSeaGreen'><b>SciPy - Optimize</b></font>

* We use function <font color='DodgerBlue'><b>sco.minimize</b></font> for which we need to provide:
    * Required:
        * Target function
        * Initial guess
    * Optional:
        * Constraints (dictionary-like: consists of constraint type and constraint function)
        * Bounds
"""

result1=sco.minimize(lambda w: qt.pV(w,ret15),
                     [1/15]*15,
                     constraints=[dict(type='eq', fun =lambda w: sum(w)-1)])
result1

"""### D

d) Assume that you are **not satisfied** with the level of **reward** which you obtain with previous portfolio. Find optimal portfolio which **provides expected return of 12%** annually.

* We cannot **disregard one dimension of investment process** (i.e. to take into account only risk without reward)
* First attempt to solve this is **Mean-Variance optimization**
    * **Minimize portfolio volatility** with **constraint** that itâ€™s **expected return** has to be **at some level**

$$(\min)\hspace{2mm}W\cdot\Sigma\cdot W$$

$$\text{s. t.}\hspace{2mm}W\cdot l=1$$

$$\text{s. t.}\hspace{2mm}W\cdot E=\mu$$

* For that we use <font color='Blue'><b>targetP</b></font>:
"""

target= qt.targetP(ret15,0.12)
target

"""* Note: exp. ret. is much higher than exp. ret. of MVP, while risk is slightly higher

#### <font color='Indigo'><b>Manual optimization 2</b></font><br>

- We need to add one new constraint
"""

result2 = sco.minimize(lambda w: qt.pV(w,ret15),[1/15]*15,
                       constraints=[dict(type='eq',fun=lambda w: sum(w)-1),
                                    dict(type='eq',fun=lambda w: qt.per(w,ret15)-0.12)])
result2

"""### E

e) Construct the optimal portfolio which provides **expected return of 30%** annually if investor **doesn't want to short sell** any asset and has **maximal allowed exposure** in single asset, which is 15%.

* Add **new constraint** as **bounds for weights**:

$$(\min)\hspace{2mm}W\cdot\Sigma\cdot W$$

$$\text{s. t.}\hspace{2mm}W\cdot l=1$$

$$\text{s. t.}\hspace{2mm}W\cdot E=\mu$$

$$\text{s. t.}\hspace{2mm}0 \leq W\leq 0.15$$
"""

res3=qt.targetP(ret15,0.3,Bounds=[0,0.15])
res3

"""* Let us round weights at 4 decimal places:
    - It is convenient to use <font color='MediumSeaGreen'><b>NumPy</b></font> since it is vectorized
"""

np.round(res3['w'],4)

"""* Note that there are **many stocks in which we doesn't invest** - this make our portfolio **less diversified**.

#### <font color='Indigo'><b>Manual optimization 3</b></font><br>
- Boundary constraint is introduced via separate argument: ***bounds***
"""

result3=sco.minimize(lambda w: qt.pV(w,ret15),
                    [1/15]*15,
                     bounds=[[0,0.15]]*15,
                     constraints = [dict(type='eq',fun=lambda w : sum(w)-1),
                                    dict(type='eq',fun=lambda w: qt.per(w,ret15)-0.3)])
result3

result3.x